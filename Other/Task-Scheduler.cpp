/*
给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。

然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。

你需要计算完成所有任务所需要的最短时间。

示例 1：

输入: tasks = ["A","A","A","B","B","B"], n = 2
输出: 8
执行顺序: A -> B -> (待命) -> A -> B -> (待命) -> A -> B.
注：

任务的总个数为 [1, 10000]。
n 的取值范围为 [0, 100]。

*/

// 参考了别人的代码
// 每次优先处理出现频率的高的作业
// 使用一个优先队列，每次循环，从中取出出现频率最高的作业，tmp保存这一轮中要处理的作业，如果一轮处理之后 tmp 中的数大于 0，说明还有这个作业，再重新加入 优先队列
// 关键是如何保证每两个相同的作业之间最少间隔了n个作业？
// 首先，一轮是 n + 1，每一轮中不允许运行一样的作业
// 再其次，对于一个作业，如果上一轮没有运行，这一轮可以直接运行，不用担心之前的 n 个 作业中有它；如果，上一轮中运行这个作业，那么它在优先队列中的优先级一定会下降，因为数量减少了，这样就保证了，即使这一轮要运行这个作业，其在这一轮中运行顺序也会低于上一轮中的运行顺序，保证了两个相同的作业之间会超过 n
//
class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        n++;
        int res = 0;
        vector<int> nums (26,0);
        priority_queue<int> q;
        for ( char task : tasks ) {
            nums[task-'A']++;
        }
        for ( int num : nums ) {
            if ( num != 0 )
                q.push(num);
        }
        while ( !q.empty() ) {
            vector<int> tmp;
            int count = 0;
            for ( int i = 0 ; i < n ; i++ ) {
                if ( !q.empty() ) {
                    tmp.push_back(q.top());
                    q.pop();
                    count++;
                }
            }
            for ( int t : tmp ) {
                t--;
                if ( t > 0 )
                    q.push(t);
            }
            if ( q.empty() )
                res += count;
            else
                res += n;
        }
        return res;
    }
};
